<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–≠–ª–µ–∫—Ç—Ä–∏–∫ 2D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: Arial; -webkit-tap-highlight-color: transparent; }
        body { background: #1a1a2e; color: #e6e6e6; padding: 8px; touch-action: manipulation; }
        header { text-align: center; padding: 10px; background: #16213e; border-radius: 8px; margin-bottom: 10px; }
        h1 { color: #ff9a3c; margin-bottom: 4px; font-size: 1.4rem; }
        .subtitle { font-size: 0.8rem; color: #8ecddd; }
        .container { display: flex; flex-direction: column; gap: 10px; height: calc(100vh - 150px); }
        @media (min-width: 768px) { .container { flex-direction: row; height: calc(100vh - 120px); } }
        .toolbar { background: #16213e; border-radius: 8px; padding: 12px; order: 2; }
        @media (min-width: 768px) { .toolbar { order: 1; width: 160px; } }
        .toolbar h2 { color: #ff9a3c; margin-bottom: 12px; font-size: 1.1rem; text-align: center; }
        .tools { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 12px; }
        @media (min-width: 768px) { .tools { grid-template-columns: 1fr; } }
        .tool { background: #0f3460; border: 2px solid #8ecddd; border-radius: 6px; padding: 10px 6px; cursor: pointer; text-align: center; font-size: 0.8rem; min-height: 50px; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: all 0.2s; }
        .tool:active { transform: scale(0.95); }
        .tool.active { border-color: #ff9a3c; background: #1a3a5f; }
        .workspace { flex: 1; background: #16213e; border-radius: 8px; padding: 12px; display: flex; flex-direction: column; order: 1; }
        .workspace-header { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
        @media (min-width: 480px) { .workspace-header { flex-direction: row; justify-content: space-between; align-items: center; } }
        .workspace-title { color: #ff9a3c; font-size: 1.2rem; text-align: center; }
        .controls { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
        @media (min-width: 480px) { .controls { grid-template-columns: repeat(4, 1fr); } }
        button { background: #0f3460; color: #e6e6e6; border: none; padding: 10px 8px; border-radius: 6px; cursor: pointer; font-size: 0.9rem; min-height: 44px; transition: all 0.2s; }
        button:active { transform: scale(0.95); background: #1a3a5f; }
        .grid-container { flex: 1; background: #0f3460; border-radius: 6px; overflow: auto; padding: 8px; -webkit-overflow-scrolling: touch; }
        #grid { display: grid; grid-template-columns: repeat(25, 20px); grid-template-rows: repeat(20, 20px); gap: 1px; margin: 0 auto; touch-action: none; }
        .cell { width: 20px; height: 20px; background: #1a3a5f; border: 1px solid #2a4a7a; cursor: pointer; position: relative; font-size: 10px; display: flex; align-items: center; justify-content: center; user-select: none; }
        .lever { background: #795548; }
        .lever.active { background: #ff9800; box-shadow: 0 0 5px #ff9800; }
        .wire { background: #5d4037; }
        .wire.active { background: #f44336; box-shadow: 0 0 4px #f44336; }
        .repeater { background: #4e342e; }
        .repeater.active { background: #e53935; box-shadow: 0 0 4px #e53935; }
        .lamp { background: #37474f; border-radius: 50%; }
        .lamp.active { background: #ffeb3b; box-shadow: 0 0 6px #ffeb3b; }
        .mover { background: #1565c0; border-radius: 3px; }
        .mover.active { background: #2196f3; box-shadow: 0 0 4px #2196f3; }
        .turner { background: #2e7d32; border-radius: 3px; }
        .turner.active { background: #4caf50; box-shadow: 0 0 4px #4caf50; }
        .toucher { background: #6a1b9a; border-radius: 3px; }
        .toucher.active { background: #9c27b0; box-shadow: 0 0 4px #9c27b0; }
        .stopper { background: #d32f2f; border-radius: 3px; }
        .stopper.active { background: #f44336; box-shadow: 0 0 4px #f44336; }
        .cycler { background: #ff6f00; border-radius: 3px; }
        .cycler.active { background: #ff9800; box-shadow: 0 0 4px #ff9800; }
        .walker { background: #00796b; border-radius: 3px; }
        .walker.active { background: #009688; box-shadow: 0 0 4px #009688; }
        .walker-path { background: #1a3a5f; border: 1px solid #4CAF50; }
        .walker-path.active { background: #4CAF50; box-shadow: 0 0 4px #4CAF50; }
        .mode-selector { display: flex; margin-top: 12px; gap: 6px; }
        .mode-btn { flex: 1; text-align: center; padding: 10px; background: #0f3460; cursor: pointer; font-size: 0.9rem; border-radius: 6px; min-height: 44px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .mode-btn.active { background: #ff9a3c; color: #1a1a2e; }
        .direction-indicator { position: absolute; font-size: 8px; color: white; font-weight: bold; }
        .bullet { position: absolute; width: 12px; height: 12px; background: #ffeb3b; border-radius: 50%; z-index: 10; }
        .instructions { background: #16213e; border-radius: 8px; padding: 12px; margin-top: 10px; font-size: 0.8rem; }
        .instructions h3 { color: #ff9a3c; margin-bottom: 8px; font-size: 0.9rem; }
        .instructions ul { padding-left: 16px; line-height: 1.4; }
        .instructions li { margin-bottom: 4px; font-size: 0.75rem; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; align-items: center; justify-content: center; }
        .modal-content { background: #16213e; padding: 20px; border-radius: 10px; text-align: center; max-width: 300px; margin: 20px; }
        .modal h3 { color: #ff9a3c; margin-bottom: 15px; }
        .modal-buttons { display: flex; gap: 10px; margin-top: 15px; }
        .modal-buttons button { flex: 1; }
        .layer-controls { display: flex; gap: 6px; margin-top: 12px; }
        .layer-btn { flex: 1; text-align: center; padding: 8px; background: #0f3460; cursor: pointer; font-size: 0.8rem; border-radius: 6px; min-height: 36px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .layer-btn.active { background: #ff9a3c; color: #1a1a2e; }
    </style>
</head>
<body>
    <header>
        <h1>–≠–ª–µ–∫—Ç—Ä–∏–∫ 2D</h1>
        <div class="subtitle">2D —Å–∏–º—É–ª—è—Ç–æ—Ä —Ä–µ–¥—Å—Ç–æ—É–Ω–∞</div>
    </header>
    
    <div class="container">
        <div class="toolbar">
            <h2>–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã</h2>
            <div class="tools">
                <div class="tool active" data-type="lever">‚ö° –†—ã—á–∞–≥</div>
                <div class="tool" data-type="wire">üîå –ü—Ä–æ–≤–æ–¥</div>
                <div class="tool" data-type="repeater">üîÅ –£–¥–ª–∏–Ω–∏—Ç–µ–ª—å</div>
                <div class="tool" data-type="lamp">üí° –õ–∞–º–ø–∞</div>
                <div class="tool" data-type="mover">üöÄ –î–≤–∏–∂–æ–∫</div>
                <div class="tool" data-type="turner">‚Üª –ü–æ–≤–æ—Ä–æ—Ç</div>
                <div class="tool" data-type="toucher">üëÜ –ö–∞—Å–∞–ª—å—â–∏–∫</div>
                <div class="tool" data-type="stopper">üõë –û—Å—Ç–∞–Ω–æ–≤—â–∏–∫</div>
                <div class="tool" data-type="cycler">üîÑ –¶–∏–∫–ª–µ—Ä</div>
                <div class="tool" data-type="walker">üö∂ –•–æ–¥–æ–≤–æ–π</div>
            </div>
            
            <div class="mode-selector">
                <div class="mode-btn active" data-mode="place">üõ†Ô∏è –°—Ç–∞–≤–∏—Ç—å</div>
                <div class="mode-btn" data-mode="delete">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</div>
            </div>
            
            <div class="layer-controls">
                <div class="layer-btn active" data-layer="1">–°–ª–æ–π 1</div>
                <div class="layer-btn" data-layer="2">–°–ª–æ–π 2</div>
                <div class="layer-btn" data-layer="3">–°–ª–æ–π 3</div>
            </div>
        </div>
        
        <div class="workspace">
            <div class="workspace-header">
                <h2 class="workspace-title">–†–∞–±–æ—á–∞—è –æ–±–ª–∞—Å—Ç—å</h2>
                <div class="controls">
                    <button id="clearBtn">üßπ –û—á–∏—Å—Ç–∏—Ç—å</button>
                    <button id="resetBtn">üîÑ –°–±—Ä–æ—Å–∏—Ç—å</button>
                    <button id="startBtn">‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç</button>
                    <button id="stopBtn">‚èπÔ∏è –°—Ç–æ–ø</button>
                </div>
            </div>
            <div class="grid-container">
                <div id="grid"></div>
            </div>
        </div>
    </div>

    <div class="instructions">
        <h3>–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:</h3>
        <ul>
            <li><strong>–†—ã—á–∞–≥</strong> - –∏—Å—Ç–æ—á–Ω–∏–∫ —Å–∏–≥–Ω–∞–ª–∞</li>
            <li><strong>–ü—Ä–æ–≤–æ–¥</strong> - –ø–µ—Ä–µ–¥–∞–µ—Ç —Å–∏–≥–Ω–∞–ª</li>
            <li><strong>–£–¥–ª–∏–Ω–∏—Ç–µ–ª—å</strong> - —É—Å–∏–ª–∏–≤–∞–µ—Ç —Å–∏–≥–Ω–∞–ª</li>
            <li><strong>–î–≤–∏–∂–æ–∫</strong> - —Å—Ç—Ä–µ–ª—è–µ—Ç –ø—É–ª—è–º–∏</li>
            <li><strong>–ü–æ–≤–æ—Ä–æ—Ç</strong> - –º–µ–Ω—è–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</li>
            <li><strong>–ö–∞—Å–∞–ª—å—â–∏–∫</strong> - –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –æ—Ç –ø—É–ª—å</li>
            <li><strong>–û—Å—Ç–∞–Ω–æ–≤—â–∏–∫</strong> - –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—É–ª–∏</li>
            <li><strong>–¶–∏–∫–ª–µ—Ä</strong> - –º–æ—Ä–≥–∞–µ—Ç 5 —Ä–∞–∑/—Å–µ–∫</li>
            <li><strong>–•–æ–¥–æ–≤–æ–π</strong> - —Ö–æ–¥–∏—Ç –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É –ø—É—Ç–∏</li>
        </ul>
    </div>

    <div id="walkerModal" class="modal">
        <div class="modal-content">
            <h3>–í—ã–±–µ—Ä–∏—Ç–µ –ø—É—Ç—å –¥–ª—è –•–æ–¥–æ–≤–æ–≥–æ</h3>
            <p>–ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ —è—á–µ–π–∫–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—É—Ç–∏ (–∑–µ–ª–µ–Ω—ã–µ)</p>
            <p>–ü–µ—Ä–≤–∞—è —è—á–µ–π–∫–∞ - –Ω–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è</p>
            <div class="modal-buttons">
                <button id="okWalker">OK</button>
                <button id="cancelWalker">–û—Ç–º–µ–Ω–∞</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const grid = document.getElementById('grid');
            const tools = document.querySelectorAll('.tool');
            const modeBtns = document.querySelectorAll('.mode-btn');
            const layerBtns = document.querySelectorAll('.layer-btn');
            const clearBtn = document.getElementById('clearBtn');
            const resetBtn = document.getElementById('resetBtn');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const walkerModal = document.getElementById('walkerModal');
            const cancelWalkerBtn = document.getElementById('cancelWalker');
            const okWalkerBtn = document.getElementById('okWalker');
            
            let selectedTool = 'lever';
            let currentMode = 'place';
            let currentLayer = 1;
            let gridData = [];
            const gridWidth = 25;
            const gridHeight = 20;
            let isSimulationRunning = false;
            let simulationInterval = null;
            let bullets = [];
            let isSelectingWalkerPath = false;
            let walkerPath = [];
            let walkerCurrentIndex = 0;
            let walkerDirection = 1; // 1 - –≤–ø–µ—Ä–µ–¥, -1 - –Ω–∞–∑–∞–¥
            
            function initGrid() {
                grid.innerHTML = '';
                gridData = [];
                bullets = [];
                stopSimulation();
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ—Ö —Å–ª–æ–µ–≤
                for (let layer = 0; layer < 3; layer++) {
                    gridData[layer] = [];
                    for (let y = 0; y < gridHeight; y++) {
                        gridData[layer][y] = [];
                        for (let x = 0; x < gridWidth; x++) {
                            gridData[layer][y][x] = { 
                                type: 'empty', 
                                active: false,
                                direction: 'right',
                                pathIndex: -1
                            };
                        }
                    }
                }
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–∏
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        
                        cell.addEventListener('click', function() {
                            handleCellClick(x, y);
                        });
                        
                        grid.appendChild(cell);
                    }
                }
                
                updateGridDisplay();
            }
            
            function updateGridDisplay() {
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                        const cellData = gridData[currentLayer-1][y][x];
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∫–ª–∞—Å—Å—ã —è—á–µ–π–∫–∏
                        cell.className = `cell ${cellData.type}`;
                        if (cellData.active) cell.classList.add('active');
                        
                        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                        const oldIndicator = cell.querySelector('.direction-indicator');
                        if (oldIndicator) oldIndicator.remove();
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
                        if ((cellData.type === 'mover' || cellData.type === 'turner' || cellData.type === 'cycler') && cellData.direction) {
                            const indicator = document.createElement('div');
                            indicator.className = 'direction-indicator';
                            switch(cellData.direction) {
                                case 'right': indicator.textContent = '‚Üí'; break;
                                case 'down': indicator.textContent = '‚Üì'; break;
                                case 'left': indicator.textContent = '‚Üê'; break;
                                case 'up': indicator.textContent = '‚Üë'; break;
                            }
                            cell.appendChild(indicator);
                        }
                    }
                }
            }
            
            function handleCellClick(x, y) {
                if (isSelectingWalkerPath) {
                    // –î–æ–±–∞–≤–ª—è–µ–º —è—á–µ–π–∫—É –≤ –ø—É—Ç—å —Ö–æ–¥–æ–≤–æ–≥–æ
                    if (gridData[currentLayer-1][y][x].type === 'empty') {
                        // –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤–∞—è —è—á–µ–π–∫–∞, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                        if (walkerPath.length === 0) {
                            gridData[currentLayer-1][y][x].type = 'walker';
                            gridData[currentLayer-1][y][x].pathIndex = 0;
                        } else {
                            gridData[currentLayer-1][y][x].type = 'walker-path';
                            gridData[currentLayer-1][y][x].pathIndex = walkerPath.length;
                        }
                        
                        walkerPath.push({x, y, layer: currentLayer-1});
                        updateGridDisplay();
                    }
                    return;
                }
                
                if (currentMode === 'delete') {
                    removeComponent(x, y);
                    return;
                }
                
                if (gridData[currentLayer-1][y][x].type !== 'empty') {
                    if (gridData[currentLayer-1][y][x].type === 'lever') {
                        toggleLever(x, y);
                    } else if (gridData[currentLayer-1][y][x].type === 'turner' || 
                               gridData[currentLayer-1][y][x].type === 'mover' || 
                               gridData[currentLayer-1][y][x].type === 'cycler') {
                        rotateComponent(x, y);
                    }
                } else {
                    if (selectedTool === 'walker') {
                        startPathSelection(x, y);
                    } else {
                        placeComponent(x, y);
                    }
                }
            }
            
            function startPathSelection(x, y) {
                walkerPath = [];
                isSelectingWalkerPath = true;
                walkerModal.style.display = 'flex';
            }
            
            function finishPathSelection() {
                isSelectingWalkerPath = false;
                walkerModal.style.display = 'none';
                walkerCurrentIndex = 0;
                walkerDirection = 1;
                
                // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ö–æ–¥–æ–≤–æ–≥–æ –Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
                if (walkerPath.length > 0) {
                    const startPos = walkerPath[0];
                    gridData[startPos.layer][startPos.y][startPos.x].active = true;
                    updateGridDisplay();
                    
                    if (gridData[startPos.layer][startPos.y][startPos.x].active) {
                        propagateSignal(startPos.x, startPos.y, startPos.layer, 15, new Set());
                    }
                }
            }
            
            function placeComponent(x, y) {
                gridData[currentLayer-1][y][x].type = selectedTool;
                gridData[currentLayer-1][y][x].active = false;
                if (selectedTool === 'mover' || selectedTool === 'turner' || selectedTool === 'cycler') {
                    gridData[currentLayer-1][y][x].direction = 'right';
                }
                updateGridDisplay();
            }
            
            function removeComponent(x, y) {
                // –ï—Å–ª–∏ —É–¥–∞–ª—è–µ–º —è—á–µ–π–∫—É –∏–∑ –ø—É—Ç–∏ —Ö–æ–¥–æ–≤–æ–≥–æ, –ø–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø—É—Ç—å
                if (gridData[currentLayer-1][y][x].pathIndex >= 0) {
                    const pathIndex = gridData[currentLayer-1][y][x].pathIndex;
                    
                    // –ù–∞—Ö–æ–¥–∏–º –∏ —É–¥–∞–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –ø—É—Ç–∏
                    const pathElementIndex = walkerPath.findIndex(p => 
                        p.x === x && p.y === y && p.layer === currentLayer-1);
                    if (pathElementIndex !== -1) {
                        walkerPath.splice(pathElementIndex, 1);
                    }
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —è—á–µ–µ–∫ –ø—É—Ç–∏
                    for (let layer = 0; layer < 3; layer++) {
                        for (let i = 0; i < gridHeight; i++) {
                            for (let j = 0; j < gridWidth; j++) {
                                if (gridData[layer][i][j].pathIndex > pathIndex) {
                                    gridData[layer][i][j].pathIndex--;
                                }
                            }
                        }
                    }
                    
                    // –ï—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏ —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é —Ö–æ–¥–æ–≤–æ–≥–æ, –ø–µ—Ä–µ–º–µ—â–∞–µ–º –µ–≥–æ
                    if (walkerCurrentIndex === pathIndex) {
                        if (walkerPath.length > 0) {
                            walkerCurrentIndex = Math.min(walkerCurrentIndex, walkerPath.length - 1);
                            const newPos = walkerPath[walkerCurrentIndex];
                            gridData[newPos.layer][newPos.y][newPos.x].type = 'walker';
                            gridData[newPos.layer][newPos.y][newPos.x].active = true;
                            updateGridDisplay();
                        }
                    }
                }
                
                gridData[currentLayer-1][y][x].type = 'empty';
                gridData[currentLayer-1][y][x].active = false;
                gridData[currentLayer-1][y][x].pathIndex = -1;
                updateGridDisplay();
            }
            
            function rotateComponent(x, y) {
                const directions = ['right', 'down', 'left', 'up'];
                const currentIndex = directions.indexOf(gridData[currentLayer-1][y][x].direction);
                gridData[currentLayer-1][y][x].direction = directions[(currentIndex + 1) % 4];
                updateGridDisplay();
            }
            
            function toggleLever(x, y) {
                gridData[currentLayer-1][y][x].active = !gridData[currentLayer-1][y][x].active;
                updateGridDisplay();
                if (gridData[currentLayer-1][y][x].active) {
                    updateCircuit();
                } else {
                    resetCircuit();
                }
            }
            
            function updateCircuit() {
                resetCircuit();
                for (let layer = 0; layer < 3; layer++) {
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            if (gridData[layer][y][x].type === 'lever' && gridData[layer][y][x].active) {
                                propagateSignal(x, y, layer, 15, new Set());
                            }
                        }
                    }
                }
            }
            
            function propagateSignal(x, y, layer, power, visited) {
                if (power <= 0) return;
                const key = `${x},${y},${layer}`;
                if (visited.has(key)) return;
                visited.add(key);
                
                const cellData = gridData[layer][y][x];
                if (cellData.type !== 'empty' && cellData.type !== 'lever' && !cellData.active) {
                    cellData.active = true;
                    updateGridDisplay();
                    
                    if (cellData.type === 'repeater') power = 15;
                    else power--;
                    
                    if (cellData.type === 'lamp') return;
                }
                
                const directions = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
                for (const dir of directions) {
                    const nx = x + dir.dx, ny = y + dir.dy;
                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        const neighbor = gridData[layer][ny][nx];
                        if (neighbor.type !== 'empty' && neighbor.type !== 'lever') {
                            propagateSignal(nx, ny, layer, power, new Set(visited));
                        }
                    }
                }
            }
            
            function startSimulation() {
                if (isSimulationRunning) return;
                isSimulationRunning = true;
                
                let lastUpdate = 0;
                let lastWalkerUpdate = 0;
                simulationInterval = setInterval(() => {
                    const now = Date.now();
                    
                    // –ü—É–ª–∏ –¥–≤–∏–≥–∞—é—Ç—Å—è –∫–∞–∂–¥—ã–µ 500–º—Å
                    if (now - lastUpdate > 500) {
                        updateBullets();
                        updateMovers();
                        updateCyclers();
                        lastUpdate = now;
                    }
                    
                    // –•–æ–¥–æ–≤–æ–π –¥–≤–∏–≥–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ 250–º—Å (4 —è—á–µ–π–∫–∏ –≤ —Å–µ–∫—É–Ω–¥—É)
                    if (now - lastWalkerUpdate > 250) {
                        updateWalkers();
                        lastWalkerUpdate = now;
                    }
                }, 100);
            }
            
            function stopSimulation() {
                isSimulationRunning = false;
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                }
                bullets = [];
                document.querySelectorAll('.bullet').forEach(bullet => bullet.remove());
            }
            
            function updateCyclers() {
                for (let layer = 0; layer < 3; layer++) {
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            if (gridData[layer][y][x].type === 'cycler') {
                                gridData[layer][y][x].active = !gridData[layer][y][x].active;
                                updateGridDisplay();
                                if (gridData[layer][y][x].active) {
                                    propagateSignal(x, y, layer, 15, new Set());
                                }
                            }
                        }
                    }
                }
            }
            
            function updateWalkers() {
                if (walkerPath.length < 2) return;
                
                // –ù–∞—Ö–æ–¥–∏–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é —Ö–æ–¥–æ–≤–æ–≥–æ
                const currentPos = walkerPath[walkerCurrentIndex];
                
                // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é
                gridData[currentPos.layer][currentPos.y][currentPos.x].active = false;
                updateGridDisplay();
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–ª–µ–¥—É—é—â—É—é –ø–æ–∑–∏—Ü–∏—é
                let nextIndex = walkerCurrentIndex + walkerDirection;
                
                // –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ –∫–æ–Ω—Ü–∞ –ø—É—Ç–∏, –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                if (nextIndex < 0 || nextIndex >= walkerPath.length) {
                    walkerDirection *= -1;
                    nextIndex = walkerCurrentIndex + walkerDirection;
                }
                
                // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ö–æ–¥–æ–≤–æ–≥–æ
                walkerCurrentIndex = nextIndex;
                const nextPos = walkerPath[walkerCurrentIndex];
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∏–ø —è—á–µ–µ–∫
                gridData[currentPos.layer][currentPos.y][currentPos.x].type = 'walker-path';
                gridData[nextPos.layer][nextPos.y][nextPos.x].type = 'walker';
                gridData[nextPos.layer][nextPos.y][nextPos.x].active = true;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                updateGridDisplay();
                
                // –ï—Å–ª–∏ —Ö–æ–¥–æ–≤–æ–π –∞–∫—Ç–∏–≤–µ–Ω, –ø–µ—Ä–µ–¥–∞–µ–º —Å–∏–≥–Ω–∞–ª
                if (gridData[nextPos.layer][nextPos.y][nextPos.x].active) {
                    propagateSignal(nextPos.x, nextPos.y, nextPos.layer, 15, new Set());
                }
            }
            
            function updateMovers() {
                for (let layer = 0; layer < 3; layer++) {
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            if (gridData[layer][y][x].type === 'mover' && gridData[layer][y][x].active) {
                                bullets.push({
                                    x: x,
                                    y: y,
                                    layer: layer,
                                    direction: gridData[layer][y][x].direction
                                });
                            }
                        }
                    }
                }
            }
            
            function updateBullets() {
                const newBullets = [];
                document.querySelectorAll('.bullet').forEach(bullet => bullet.remove());
                
                for (const bullet of bullets) {
                    let {x, y, layer, direction} = bullet;
                    let nx = x, ny = y;
                    switch(direction) {
                        case 'right': nx = x + 1; break;
                        case 'down': ny = y + 1; break;
                        case 'left': nx = x - 1; break;
                        case 'up': ny = y - 1; break;
                    }
                    
                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        const nextCell = gridData[layer][ny][nx];
                        
                        if (nextCell.type === 'stopper') continue;
                        if (nextCell.type === 'turner') direction = nextCell.direction;
                        if (nextCell.type === 'toucher') {
                            nextCell.active = true;
                            updateGridDisplay();
                        }
                        
                        newBullets.push({x: nx, y: ny, layer, direction});
                        
                        const cell = document.querySelector(`.cell[data-x="${nx}"][data-y="${ny}"]`);
                        if (cell) {
                            const bulletElement = document.createElement('div');
                            bulletElement.className = 'bullet';
                            cell.appendChild(bulletElement);
                        }
                    }
                }
                bullets = newBullets;
            }
            
            function resetCircuit() {
                stopSimulation();
                for (let layer = 0; layer < 3; layer++) {
                    for (let y = 0; y < gridHeight; y++) {
                        for (let x = 0; x < gridWidth; x++) {
                            if (gridData[layer][y][x].type !== 'lever') {
                                gridData[layer][y][x].active = false;
                            }
                        }
                    }
                }
                updateGridDisplay();
            }
            
            // –°–æ–±—ã—Ç–∏—è
            tools.forEach(tool => {
                tool.addEventListener('click', function() {
                    tools.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    selectedTool = this.dataset.type;
                });
            });
            
            modeBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    modeBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentMode = this.dataset.mode;
                });
            });
            
            layerBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    layerBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentLayer = parseInt(this.dataset.layer);
                    updateGridDisplay();
                });
            });
            
            clearBtn.addEventListener('click', initGrid);
            resetBtn.addEventListener('click', resetCircuit);
            startBtn.addEventListener('click', startSimulation);
            stopBtn.addEventListener('click', stopSimulation);
            cancelWalkerBtn.addEventListener('click', function() {
                walkerModal.style.display = 'none';
                isSelectingWalkerPath = false;
                // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —è—á–µ–π–∫–∏ –ø—É—Ç–∏
                for (const pos of walkerPath) {
                    gridData[pos.layer][pos.y][pos.x].type = 'empty';
                    gridData[pos.layer][pos.y][pos.x].pathIndex = -1;
                }
                walkerPath = [];
                updateGridDisplay();
            });
            
            okWalkerBtn.addEventListener('click', finishPathSelection);
            
            initGrid();
        });
    </script>
</body>
  </html> 
